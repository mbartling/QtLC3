<!DOCTYPE html>
<html>
<body>
  <h1>JSR</h1>
  <p>Jump to Subroutine</p>
  <h1>JSRR</h1>
  <p>Jump to Subroutine (Register)</p>

  <h2>Assembler Formats</h2>
  <p>JSR LABEL</p>
  <p>JSRR BaseR</p>
  <h2>Encodings</h2>
<a href="http://res.cloudinary.com/de9kbeo0h/image/upload/v1434222547/JSR_encoding_te04rp.png">Check Here</a>
  <h2>Operation</h2>
  <pre>
    <code>
      R7 = PC*;
      if (bit[11] == 0)
         PC = BaseR;
      else 
         PC = PC* + SEXT(PCoffset11);
    </code>
  </pre>

  <h2>Description</h2>
  <p>
   First, the incremented PC is saved in R7. This is the linkage back to the calling routine. Then the PC is loaded with the address of the first instruction of the subroutine, causing an unconditional jump to that address. The address of the subroutine is obtained from the base register (if bit [11] is 0), or the address is computed by sign-extending bits [10:0] and adding this value to the incremented PC (if bit [11] is 1).
  </p>
  <h2>Examples</h2>
  <pre>
    <code>
      JSR QUEUE ; Put the address of the instruction following JSR into R7;
                ; Jump to QUEUE.

      JSRR R3   ; Put the address following JSRR into R7; Jump to the
                ; address contained in R3.
    </code>
  </pre>

</body>
<footer>
  <p>PC*: This is the incremented PC</p>
</footer>
</html>
